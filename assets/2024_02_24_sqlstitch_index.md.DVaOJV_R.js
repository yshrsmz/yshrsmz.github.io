import{_ as i,o as a,a as t,X as l}from"./chunks/framework.BPPv2K3c.js";const c=JSON.parse('{"title":"複数の DDL ファイルを外部キー依存順に並べて結合するツール、 sqlstitch を作った","description":"","frontmatter":{"layout":"post","title":"複数の DDL ファイルを外部キー依存順に並べて結合するツール、 sqlstitch を作った","tags":["SQL","Rust","sqlstitch","GitHub Copilot"],"head":[["link",{"rel":"canonical","href":"https://www.codingfeline.com/2024/02/24/sqlstitch/"}],["meta",{"property":"og:url","content":"https://www.codingfeline.com/2024/02/24/sqlstitch/"}],["meta",{"property":"og:title","content":"複数の DDL ファイルを外部キー依存順に並べて結合するツール、 sqlstitch を作った"}],["meta",{"property":"twitter:card","content":"summary_large_image"}],["meta",{"property":"twitter:site","content":"@_yshrsmz"}],["meta",{"property":"twitter:creator","content":"@_yshrsmz"}],["meta",{"property":"og:image","content":"https://www.codingfeline.com/2024/02/24/sqlstitch/ogp.png"}]]},"headers":[],"relativePath":"2024/02/24/sqlstitch/index.md","filePath":"posts/2024/2024-02-24-sqlstitch.md","date":{"time":"2024-02-24","string":"February 24, 2024","year":"2024","month":"02","day":"24"}}'),h={name:"2024/02/24/sqlstitch/index.md"};function n(e,s,p,k,r,d){return a(),t("div",null,[...s[0]||(s[0]=[l(`<p>スキーマ定義をテーブル毎にファイル分割したい、でもなにも考えずに結合するとそのまま流せなくない？　を解決するツール</p><p><strong>目次</strong></p><nav class="table-of-contents"><ul><li><a href="#レポジトリ">レポジトリ</a></li><li><a href="#これはなに">これはなに</a></li><li><a href="#使い方">使い方</a></li><li><a href="#なぜ作ったか">なぜ作ったか</a></li><li><a href="#どう作ったか">どう作ったか</a></li><li><a href="#まとめ">まとめ</a></li></ul></nav><h2 id="レポジトリ" tabindex="-1">レポジトリ <a class="header-anchor" href="#レポジトリ" aria-label="Permalink to &quot;レポジトリ&quot;">​</a></h2><p><a href="https://github.com/yshrsmz/sqlstitch" target="_blank" rel="noreferrer">https://github.com/yshrsmz/sqlstitch</a></p><h2 id="これはなに" tabindex="-1">これはなに <a class="header-anchor" href="#これはなに" aria-label="Permalink to &quot;これはなに&quot;">​</a></h2><p>端的にいうと、スキーマ定義用の DDL を複数ファイルに分割して管理しているときに、関連順に並び替えて結合してくれるツール。</p><p>スキーマが大きくなってくると、メンテナンス性維持のためにたとえば <code>CREATE TABLE</code> 単位でファイルを分割したくなる。ただ、ファイルを分割すると今度は実行順序を気にする必要がでてくる。単純に <code>cat</code> するとファイル名順で結合されるので、外部キー制約的に無理のない順番になっているとは限らない(というかならないだろう)</p><p>そこで <code>sqlstitch</code> の出番だ。このツールは結合対象のファイル内の <code>CREATE TABLE</code> を解析し、外部キー制約でトポロジカルソートをかけ、その結果を標準出力に表示する。出力された SQL 群はそのまま実行可能な順番にならんでいる。</p><h2 id="使い方" tabindex="-1">使い方 <a class="header-anchor" href="#使い方" aria-label="Permalink to &quot;使い方&quot;">​</a></h2><p>たとえば <code>tables</code> ディレクトリ配下に以下の様な SQL ファイルがあるとする</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- authors.sql</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> authors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  author_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NOT NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AUTO_INCREMENT,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> VARCHAR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NOT NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  PRIMARY KEY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (author_id)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- comments.sql</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> comment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  comment_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NOT NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AUTO_INCREMENT,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  body </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TEXT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NOT NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  post_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NOT NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  PRIMARY KEY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (comment_id),</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  CONSTRAINT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fk_post_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FOREIGN KEY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> post_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">REFERENCES</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> posts (post_id)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- posts.sql</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> posts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  post_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NOT NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AUTO_INCREMENT,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  body </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TEXT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NOT NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  author_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NOT NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  PRIMARY KEY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (post_id),</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  CONSTRAINT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fk_author_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FOREIGN KEY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> author_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">REFERENCES</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> authors (author_id)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>このように３つの sql ファイルがあったとき、</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tables/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.sql</span></span></code></pre></div><p>のように <code>cat</code> コマンドを利用すると、単純に名前の順に <code>accounts.sql</code>, <code>comments.sql</code>, <code>posts.sql</code> の順で結合されてしまう。ところが <code>comments</code> テーブルは外部キー制約で <code>posts</code> テーブルを参照しているので、結合された結果をこのまま DB に流すことはできない。</p><p>ここで代わりに <code>sqlstitch</code> を使うと、</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sqlstitch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tables/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.sql</span></span></code></pre></div><p>外部キー制約を考慮して、<code>accounts.sql</code>, <code>posts.sql</code>, <code>comments.sql</code> の順で結合したものを出力してくれる、というわけだ。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sqlstitch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tables/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.sql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mysql</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --host</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> localhost</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --user</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> root</span></span></code></pre></div><p>的なこともできる</p><h2 id="なぜ作ったか" tabindex="-1">なぜ作ったか <a class="header-anchor" href="#なぜ作ったか" aria-label="Permalink to &quot;なぜ作ったか&quot;">​</a></h2><p>開発中の新しいアプリで、DB 周りを sqlc x sqldef でいこう、という話になったから。</p><p>sqlc はローカルにある DDL と DML から DB アクセス用のコードを自動生成してくれるし、sqldef はローカルの DDL と DB 上のスキーマを比較して、マイグレーション用の DDL を生成してくれる。</p><p>これらを使えば SQL をいわゆる single source of truth として DB 周りを整備できるのでは…? と言う話になったのだ。</p><p>ただ sqldef はマイグレーション用 DDL 作成時に<a href="https://github.com/sqldef/sqldef/issues/405" target="_blank" rel="noreferrer">テーブル間の関連を考慮してくれない</a>ので、こちら側でちゃんとエラーが発生せずに流せる順序に DDL を並べた状態で渡してあげる必要がある。</p><p>しかしだからといってスキーマ定義を 1 ファイルでまとめて定義するのは、前述のようにメンテナンス性の観点から避けたい。既存のツールはパッと探した感じだと見当たらなかったので、自分で作ってしまおう、ということになった。</p><h2 id="どう作ったか" tabindex="-1">どう作ったか <a class="header-anchor" href="#どう作ったか" aria-label="Permalink to &quot;どう作ったか&quot;">​</a></h2><p>せっかくなので気になっていた Rust を採用。</p><p><a href="https://doc.rust-jp.rs/book-ja/" target="_blank" rel="noreferrer">The Rust Programming Language 日本語版</a> 読みつつ、わからんところは GitHub Copilot Chat に聞きつつ、という感じでシュッと形にすることはできた。</p><p>GitHub Copilot Chat は大変優秀で、たまに別ライブラリの構文混ざってきて動かないコードサジェストすることもあるものの、ドキュメント読みながらであればだいたいなんとかなる回答がもらえる。</p><p>たとえば、「各テーブルに <code>CREATE TABLE</code> が一つずつ格納されたファイルが複数あります。これを外部キーでソートするにはどうしたらいいですか」と質問するとこんな感じになる。</p><p><img src="https://lh3.googleusercontent.com/pw/ABLVV86tf1YQMhv6SsFncAnnA5RjR6JJeWphuHVra6UnYX-NYs-E42r5e2Yazaf3JyricF65_dDUPB3cmcz1WIihLsfKMJEAjFvE9lcpbu6laoNgHtl8IssImaX8MCYb81VgpVE9Qz1leiiIVRksoiCTrTnUzA=w800" alt=""></p><p>これで「適当なパーサー使って DDL パースして外部キー制約を取り出す」「取り出した外部キー制約でトポロジカルソートする」ということはわかるので、このそれぞれのステップについて I/F 決めて実装する、あるいは追加で質問していけばいい。完全に GitHub Copilot にお任せ、というよりは質問をベースにこちらで I/F 定義など追加情報を与えていくと、いい感じの成果物をくれそう。</p><p>とはいえ細かいところでは雑な箇所もあるので、最終的な真贋を見極めて修正するところはまだ人間の手が必要なイメージだ。</p><h2 id="まとめ" tabindex="-1">まとめ <a class="header-anchor" href="#まとめ" aria-label="Permalink to &quot;まとめ&quot;">​</a></h2><p>とりあえずこれで必要なユースケースは満たせたものの、現状はいくつか課題がある</p><ul><li>CREATE TABLE しか対応してない <ul><li>ALTER TABLE は無理</li><li>CREATE VIEW は無理</li></ul></li><li>ファイル内の並び替えは対応していない</li></ul><p>今後は地道にこのへんなおしていく感じかなー。</p>`,40)])])}const E=i(h,[["render",n]]);export{c as __pageData,E as default};
