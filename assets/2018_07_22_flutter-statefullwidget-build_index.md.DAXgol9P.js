import{_ as e,o as d,a as o,X as l}from"./chunks/framework.BPPv2K3c.js";const f=JSON.parse('{"title":"(Flutter) なぜStatefullWidgetではなくStateがbuildメソッドを持っているのか","description":"","frontmatter":{"layout":"post","title":"(Flutter) なぜStatefullWidgetではなくStateがbuildメソッドを持っているのか","category":"programming","tags":["TIL","flutter"],"head":[["link",{"rel":"canonical","href":"https://www.codingfeline.com/2018/07/22/flutter-statefullwidget-build/"}],["meta",{"property":"og:url","content":"https://www.codingfeline.com/2018/07/22/flutter-statefullwidget-build/"}],["meta",{"property":"og:title","content":"(Flutter) なぜStatefullWidgetではなくStateがbuildメソッドを持っているのか"}],["meta",{"property":"twitter:card","content":"summary_large_image"}],["meta",{"property":"twitter:site","content":"@_yshrsmz"}],["meta",{"property":"twitter:creator","content":"@_yshrsmz"}],["meta",{"property":"og:image","content":"https://www.codingfeline.com/2018/07/22/flutter-statefullwidget-build/ogp.png"}]]},"headers":[],"relativePath":"2018/07/22/flutter-statefullwidget-build/index.md","filePath":"posts/2018/2018-07-22-flutter-statefullwidget-build.md","date":{"time":"2018-07-22","string":"July 22, 2018","year":"2018","month":"07","day":"22"}}'),a={name:"2018/07/22/flutter-statefullwidget-build/index.md"};function i(r,t,c,u,p,n){return d(),o("div",null,[...t[0]||(t[0]=[l('<p>最近趣味と実益を兼ねてFlutterを触っている。</p><p>だいたいReactっぽくて良さそうな感じ。React Nativeと違って、UIレイヤについては基本的にFlutterの中で完結するのが好み。</p><p>ただ<code>StatefulWidget</code>を作るときにちょっと気になることがあった。<code>StatefulWidget</code>はそれ以外にWidgetの状態を管理する<code>State</code>クラスが必要なんだけど、<code>StatefulWidget</code>ではなく<code>State</code>の方にUIを描画する<code>build</code>メソッドがあるのだ。</p><p>ReactでもそうだしMVPやらMVVMでもそうだけど、だいたい状態を管理するクラスとUIを描画するクラスを分離することで責任を分離している。それをなぜわざわざ<code>State</code>クラスに<code>build</code>メソッドが生えているんだろう？　と違和感しかなかった。</p><p>そんなわけでちょっと調べてみたら、やっぱり同じように思う人はいたらしくissueがたっていた。</p><p><a href="https://github.com/flutter/flutter/issues/8794" target="_blank" rel="noreferrer">FAQ request: why is the build() method on State, and not StatefulWidget ?</a></p><p>要約すると下記のような理由らしい。</p><p><code>StatefulWidget</code>に<code>build</code>メソッドを生やすことにすると、メソッドシグネチャが<code>StatefulWidget#build(BuildContext, State)</code>になる。<br> このメソッドの中でクロージャを定義すると暗黙的に<code>this(この場合はStatefulWidget)</code>がキャプチャされる。で、<code>build</code>メソッドが呼ばれたときに、<code>StatefulWidget</code>は作り直されたにも関わらずクロージャの<code>this</code>は古い<code>StatefulWidget</code>を参照したままで古い状態を参照してしまう。<br> 一方<code>State#build(BuildContext)</code>であれば、<code>State</code>は<code>StatefulWidget</code>が再生成されたときでもそのまま保持されるので、<code>this</code>の対象が変わることはない、ということだ。</p><p>あとは、<code>StatefulWidget#build(BuildContext, State)</code>だと、これ継承した新しい<code>StatefulWidget</code>を作ったときに実装の詳細である<code>State</code>を子クラスに公開しなければならなくなる、とか。</p><p>仕様的にこうせざるを得なかった、というのはわかったけどやっぱり釈然としない感じはある。</p><p>こういった点を何とかするためにBLoCパターンとかMVW系のデザインパターンを実装するんだろうけど、そのへんはまだ分かりきっていないので引き続き調べる。</p><p>ちなみに上述のissueの中身は現在<a href="https://docs.flutter.io/flutter/widgets/State/build.html" target="_blank" rel="noreferrer">APIドキュメントの方</a>にも記載されている。</p>',12)])])}const g=e(a,[["render",i]]);export{f as __pageData,g as default};
